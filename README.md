# Microservices-template

## Technologies used

1. [Node](https://nodejs.org/uk/) v8.12

1. [yarn](https://yarnpkg.com/en/) (instead of npm)

   Yarn is faster and it has more reliable dependencies lock mechanism.

1. Typescript

1. [NestJS](https://docs.nestjs.com/) - Web and microservice framework

1. [Docker](https://www.docker.com/) - containers management software

1. [docker-compose](https://docs.docker.com/compose/) - is used to orchestrate multiple Docker containers. In our case is used for local development only.

1. [Auth0](https://auth0.com/) - robust and secure authentication platform

1. [Jest](https://jestjs.io) - testing framework

## Project structure overview

Microservices-template approach (one repo for multiple independent projects) reduces
effort needed to manage services that communicate with each other.

In conjunction with docker and docker-compose it allows, by using just couple of commands,
have a production-like setup locally.

Let's have a look at the folders structure

```
├── microservices
│   ├── api-gateway
│   └── ...
├── package.json
├── tslint.json
├── README.md
├── docker-compose.yaml
└── yarn.lock
```

- **microservices** - this folder contains microservice projects.
  For example api-gateway is independent project and can be built and run on independently. They have own package.json.

  - **api-gateway** - [API Gateway](https://microservices.io/patterns/apigateway.html) is an entry point to our microservices, that manages auth,
    rate limiting and other cross-cutting concerns for microservices.

    **Note:** Later on we'll create a [separate git repository](https://medium.com/@patrickleet/mono-repo-or-multi-repo-why-choose-one-when-you-can-have-both-e9c77bd0c668) for each microservice. So that they can be released independently

- **docker-compose** - this file defines how to spin up the microservices' docker containers in order to have a local development infrastructure up and running
- **tslint.json** - this is a typescript linter configuration.
- **package.json** - contains monorepo (only monorepo) dependencies and scripts specific to monorepo project
- **yarn.lock** - file generated by yarn package-manager which makes sure we have reproducable dependency graph.

## Local development

### How to run microservices locally using docker-compose

1. Make sure you have Docker and docker-compose installed

- [Ubuntu](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
- [Windows](https://docs.docker.com/docker-for-windows/)
- [macOS](https://docs.docker.com/docker-for-mac/)

1. Type `docker --version` in your terminal - you should see output from this command

1. Type `docker-compose --version` in your terminal - you should see output from this command

1. Make sure you have [yarn](https://yarnpkg.com/lang/en/docs/install/#mac-stable) installed (choose your OS in the dropdown there)

1. Type `yarn --version` in your terminal - you should see output from this command

1. `git clone git@github.com:Technorely/Microservices-template.git`

2. `cd microservices-template`

3. `yarn` - this is a command so just type it and hit "Enter". It'll install project dependencies

4. In each microservice should find `.env.template`, rename it to `.env` and adjust environment variables inside accordingly (though by default it should work without adjustments)
   Note, that .env file should be used only for local development. On a production environment you should use environment variables directly in order to avoid security issues.

5. `docker-compose build` - builds docker images using Dockerfile that exists in every
   subfoler of **microservices** folder.

6. `docker-compose up --force-recreate` - start the Docker containers using images built on the previous step and recreates containers on every run.

### Nodemon - automatically restarting the node application when file changes in the directory are detected.

Once you have the app up and running by docker-compose,
you can start working on the codebase.

Every change in microservices' codebase will force that microservice to restart
in the Docker container, so that changes can be available in the running microservice.

This is done by [Nodemon](https://github.com/remy/nodemon).

### Debug microservices deployed in Docker containers locally

You can debug microservices that are running inside Docker containers.
For that you need to go to `docker-compose.yml` and do changes
described below (for each microservice you want to debug):

1. In `command: ['npm', 'run', 'start:dev']`, **start:dev** should be changed to **start:debug**

1. Specify a `DEBUG_PORT` (**it can be any available port**) environment variable under `environment:` section

   ```
     environment:
       - DEBUG_PORT=9229
   ```

1. Expose the port number you've added at the previous step by adding it to the `ports:` section

   ```
     ports:
       - '9229:9229'
   ```

1. Now this debug port is available on your localhost

1. As a next step you need to install [NiM](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj/related) extension into your Chrome browser

1. In chrome, click on NiM icon and it'll open a debugger, where you can put breakpoints etc.

> **_Note:_** Because every microservice is a separate node app, you can
> work with it on its own without Docker containers, just by running _npm run start:dev_

## Conventions

### Linting, code style, commit messages

Developers spend lots of time reading the code, written by others. So we need to ensure code style consistency and enforce best practices by utilizing **tslint**, **prettier**, **validate-commit-msg**.

[**tslint**](https://palantir.github.io/tslint/) is an extensible static analysis tool that checks [TypeScript](http://www.typescriptlang.org/) code for readability, maintainability, and functionality errors. It is widely supported across modern editors & build systems and can be customized with your own lint rules, configurations, and formatters.

[**prettier**](https://prettier.io/) is a code formatter. It enforces a consistent style by parsing your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.

**validate-commit-msg** - makes sure that every commit message follows [ESLint](https://github.com/conventional-changelog-archived-repos/conventional-changelog-eslint/blob/master/convention.md)

### Git Flow

https://gist.github.com/forest/19fc774dde34f77e2540

## Troubleshooting

### You cannot delete `node_modules` directory and yarn requires extra permissions to install there a package

Try to `sudo rm -rf node_modules` and reinstall your dependencies
